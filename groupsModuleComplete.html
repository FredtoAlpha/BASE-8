<script>
(function(global) {
  'use strict';

  /*
  ════════════════════════════════════════════════════════════════════════
    MODULE COMPLET DE GESTION DES GROUPES
    - Groupes de Besoins (scores Math/Français)
    - Groupes LV2 (ESP/ITA/autres langues)
    - Groupes Options (future extension)
    - Drag & Drop entre groupes
    - Export GROUPES / PDF / CSV
  ════════════════════════════════════════════════════════════════════════
  */

  // VERSION 4.0 - Octobre 2025 - GROUPS MODULE (NE PAS SUPPRIMER)

  const windowRef =
    typeof window !== 'undefined'
      ? window
      : (typeof globalThis !== 'undefined' ? globalThis : undefined);
  const documentRef = windowRef?.document;

  if (!windowRef || !documentRef) {
    console.log('❌ GroupsModuleComplete: environnement navigateur non détecté');
    return;
  }

  console.log('🚀 Chargement du Module Complet de Gestion des Groupes...');

  // ═══════════════════════════════════════════════════════════════
  //  CONSTANTES
  // ═══════════════════════════════════════════════════════════════

  const GROUP_TYPES = {
    needs: {
      id: 'needs',
      title: 'Groupes de Besoins',
      description: 'Groupes hétérogènes basés sur les scores Math/Français et critères pédagogiques',
      icon: '📊',
      color: 'from-blue-600 to-indigo-600',
      bgColor: 'bg-blue-50',
      borderColor: 'border-blue-200'
    },
    language: {
      id: 'language',
      title: 'Groupes LV2',
      description: 'Groupes de langues (ESP/ITA) avec priorité à la participation',
      icon: '🗣️',
      color: 'from-purple-600 to-pink-600',
      bgColor: 'bg-purple-50',
      borderColor: 'border-purple-200'
    },
    option: {
      id: 'option',
      title: 'Groupes Options',
      description: 'Groupes basés sur les options choisies (à venir)',
      icon: '🎨',
      color: 'from-emerald-600 to-teal-600',
      bgColor: 'bg-emerald-50',
      borderColor: 'border-emerald-200',
      disabled: true
    }
  };

  const SUBJECTS = {
    both: { id: 'both', label: 'Math + Français', icon: '📐📚' },
    maths: { id: 'maths', label: 'Mathématiques', icon: '📐' },
    french: { id: 'french', label: 'Français', icon: '📚' }
  };

  const DISTRIBUTION_TYPES = {
    heterogeneous: { id: 'heterogeneous', label: 'Hétérogène (tous niveaux mélangés)', recommended: true },
    homogeneous: { id: 'homogeneous', label: 'Homogène (par niveau)' }
  };

  // ═══════════════════════════════════════════════════════════════
  //  ÉTAT GLOBAL
  // ═══════════════════════════════════════════════════════════════

  const state = {
    // Navigation
    currentStep: 1,
    totalSteps: 5,

    // Configuration
    groupType: null,                    // 'needs' | 'language' | 'option'
    selectedClasses: [],                // ['6°1', '6°2', ...] (noms affichage)
    availableClasses: [],               // Classes visibles dans le board
    numGroups: 3,                       // Nombre de groupes à créer

    // Config spécifique Besoins
    selectedSubject: 'both',            // 'both' | 'maths' | 'french'
    distributionType: 'heterogeneous',  // 'heterogeneous' | 'homogeneous'

    // Config spécifique LV2
    selectedLanguage: 'ESP',            // 'ESP' | 'ITA' | autre
    availableLanguages: [],             // Langues détectées

    // 🆕 Données brutes et mapping
    classesData: {},                    // Dump brut du backend : { "6°1FIN": { eleves:[...] }, ... }
    classKeyMap: {},                    // Mapping affichage -> backend : { "6°1": "6°1FIN", ... }

    // Données
    students: [],                       // Tous les élèves des classes sélectionnées
    studentsById: new Map(),            // Map pour accès rapide
    generatedGroups: [],                // Groupes générés

    // UI
    modal: null,
    isLoading: false,
    loadError: null,
    lastGeneration: null,

    // Drag & Drop
    sortables: [],

    // Statistiques
    showStatistics: true,

    // 🆕 Mode de sauvegarde (pour workflow multi-phase)
    saveMode: 'append'                  // 'replace' | 'append' (défaut append pour workflow multi-phase)
  };

  // ═══════════════════════════════════════════════════════════════
  //  UTILITAIRES
  // ═══════════════════════════════════════════════════════════════

  function qs(selector, scope = documentRef) {
    return scope?.querySelector(selector);
  }

  function qsa(selector, scope = documentRef) {
    return Array.from(scope?.querySelectorAll(selector) || []);
  }

  function showToast(message, type = 'info', duration = 3500) {
    try {
      const toast = documentRef.createElement('div');
      toast.className = 'fixed top-6 right-6 z-[9999] px-6 py-4 rounded-2xl shadow-2xl text-white font-semibold flex items-center gap-3 animate-slide-in';

      const colors = {
        error: 'linear-gradient(135deg, #ef4444, #dc2626)',
        success: 'linear-gradient(135deg, #22c55e, #16a34a)',
        warning: 'linear-gradient(135deg, #f59e0b, #d97706)',
        info: 'linear-gradient(135deg, #6366f1, #7c3aed)'
      };

      const icons = {
        error: 'fa-circle-exclamation',
        success: 'fa-circle-check',
        warning: 'fa-triangle-exclamation',
        info: 'fa-circle-info'
      };

      toast.style.background = colors[type] || colors.info;
      toast.innerHTML = `<i class="fas ${icons[type] || icons.info}"></i><span>${message}</span>`;

      documentRef.body.appendChild(toast);

      setTimeout(() => {
        toast.style.opacity = '0';
        toast.style.transform = 'translateY(-10px)';
        setTimeout(() => toast.remove(), 250);
      }, duration);
    } catch (error) {
      console.error('❌ Erreur showToast:', error);
    }
  }

  function formatDate(date) {
    return new Date(date).toLocaleString('fr-FR', {
      day: '2-digit',
      month: '2-digit',
      year: 'numeric',
      hour: '2-digit',
      minute: '2-digit'
    });
  }

  // ═══════════════════════════════════════════════════════════════
  //  NORMALISATION DES SCORES
  // ═══════════════════════════════════════════════════════════════
  // Fallback pour les scores manquants ou mal formatés
  // Gère les trois formats : scores.F/M, scoreF/scoreM, SCORE_F/SCORE_M
  function normalizeScores(student) {
    if (!student) return student;

    const toNum = v => (v === '' || v == null) ? null : Number(v);

    // Chercher F (Français) dans les trois lieux possibles
    const f = toNum(
      student?.scores?.F ??
      student?.scoreF ??
      student?.SCORE_F ??
      null
    );

    // Chercher M (Mathématiques) dans les trois lieux possibles
    const m = toNum(
      student?.scores?.M ??
      student?.scoreM ??
      student?.SCORE_M ??
      null
    );

    // Garantir la structure scores.F/M
    if (!student.scores) {
      student.scores = {};
    }
    student.scores.F = Number.isFinite(f) ? f : null;
    student.scores.M = Number.isFinite(m) ? m : null;

    // Garder aussi les top-level pour compatibilité
    student.scoreF = student.scores.F;
    student.scoreM = student.scores.M;

    return student;
  }

  // ═══════════════════════════════════════════════════════════════
  //  DÉTECTION DES VRAIES CLASSES PÉDAGOGIQUES
  // ═══════════════════════════════════════════════════════════════

  // Helper : Transforme un nom de classe en forme CANONIQUE pour comparaison.
  // Exemples :
  //   "6°1" → "6#1"
  //   "6°2FIN" → "6#2"
  //   "6E2FIN" → "6#2"
  //   "3E1" → "3#1"
  // Ça permet de matcher "6°1" (DOM) avec "6E1FIN" (backend) via leur forme canonique commune.
  function canonicalClass(name) {
    let s = (name || '')
      .toString()
      .trim()
      .toUpperCase();

    // Unifie "6°2" et "6E2" → "6#2"
    s = s.replace(/^(\d)[E°]/, '$1#');

    // Retire tout ce qui n'est pas [0-9 A-Z #]
    s = s.replace(/[^0-9A-Z#]/g, '');

    return s;
  }

  // Helper : Est-ce que ce nom est une vraie classe pédagogique (ex: "6°1", "5°2", "3E2") ?
  // Rejette les groupes, CHAV, DYS, soutien, besoins, LV2, etc.
  function localIsRealClass(name) {
    if (!name || typeof name !== 'string') return false;

    name = name.trim();

    // Patterns d'exclusion : trucs techniques, groupes de besoin, etc.
    const badPatterns = [
      /^GROUPE/i,
      /^GRP/i,
      /GROUPE/i,
      /_LV2/i,
      /_LV1/i,
      /_LV3/i,
      /_CHAV/i,
      /_DYS/i,
      /_SOUTIEN/i,
      /_BESOINS/i,
    ];

    for (const p of badPatterns) {
      if (p.test(name)) return false;
    }

    // Pattern cible : "6°1", "5°2", "3E2", etc.
    // On accepte chiffre + (° ou E) + chiffre
    const pedagogicPattern = /^(\d+[°E]\d+)$/i;
    return pedagogicPattern.test(name);
  }

  // Détecte les vraies classes directement dans le DOM (colonnes visibles du board)
  // C'est la "vérité de terrain" pour le chef d'établissement
  function detectClassesFromDOM() {
    const zones = documentRef.querySelectorAll('.droppable-zone[data-classe]');
    const list = [];

    zones.forEach(z => {
      const cid = (z.getAttribute('data-classe') || '').trim();
      if (cid && localIsRealClass(cid) && !list.includes(cid)) {
        list.push(cid);
      }
    });

    return list;
  }

  // ═══════════════════════════════════════════════════════════════
  //  SNAPSHOT DES CLASSES ET ÉLÈVES DEPUIS LE DOM
  // ═══════════════════════════════════════════════════════════════
  // Reconstruit un snapshot { "6°1": { eleves:[ {...}, {...} ] }, ... }
  // en lisant DIRECTEMENT le board visible.
  // Source unique de vérité : ce que le chef voit à l'écran.
  function snapshotClassesFromDOMForGroups() {
    const zones = documentRef.querySelectorAll('.droppable-zone[data-classe]');
    const snapshot = {};

    zones.forEach(zone => {
      const classId = (zone.getAttribute('data-classe') || '').trim();
      if (!classId) return;
      if (!localIsRealClass(classId)) return;

      // Prépare le bucket pour cette classe
      snapshot[classId] = { eleves: [] };

      // Récupère toutes les cartes élèves visibles dans cette classe
      const cards = zone.querySelectorAll('.student-card');

      cards.forEach(card => {
        // ID élève : on accepte les deux syntaxes
        const sid =
          card.getAttribute('data-id') ||
          card.getAttribute('data-student-id') ||
          card.dataset.id ||
          card.dataset.studentId;

        if (!sid) return;

        // On va chercher la fiche complète dans STATE.students
        const fullData = windowRef.STATE?.students?.[sid];

        if (fullData) {
          // On clone pour ne pas muter l'original
          const clone = { ...fullData };

          // On force la classe actuelle visible
          clone.classe = classId;

          snapshot[classId].eleves.push(clone);
        } else {
          // Fallback ultra-minimal si jamais l'élève n'est pas dans STATE.students
          const nom = (card.querySelector('.sc-nom')?.textContent || '').trim();
          const prenom = (card.querySelector('.sc-prenom')?.textContent || '').trim();
          const sexe = card.getAttribute('data-sexe') ||
                       card.querySelector('.tag-sex')?.textContent?.trim() ||
                       '';
          const source = card.getAttribute('data-source') || ''; // classe d'origine

          snapshot[classId].eleves.push({
            id: sid,
            nom,
            prenom,
            sexe,
            classe: classId,
            source: source,
            scores: {} // pas idéal mais ça évite les crash
          });
        }
      });
    });

    // Debug utile
    Object.keys(snapshot).forEach(cid => {
      console.log(
        `[GroupsModule] Snapshot DOM → ${cid}: ${snapshot[cid].eleves.length} élèves`
      );
    });

    return snapshot;
  }

  // ========== FONCTION HELPER POUR SIMPLIFIER LES NOMS COMPOSÉS ==========
  // Utilise la version globale 4.3 définie dans InterfaceV2_CoreScript
  // Plus de doublon - référence unique
  
  function simplifierNomComplet(nom, prenom) {
    // Utiliser la version globale 4.3 si disponible
    if (
      windowRef.simplifierNomComplet &&
      typeof windowRef.simplifierNomComplet === 'function'
    ) {
      return windowRef.simplifierNomComplet(nom, prenom);
    }

    // Fallback simple si la version globale n'est pas chargée
    console.warn('⚠️ Version globale simplifierNomComplet non trouvée, utilisation fallback');
    if (!nom && !prenom) return '';
    const nomSimple = (nom || '').trim().split(/[\s-]+/)[0];
    const prenomSimple = (prenom || '').trim().split(/[\s-]+/)[0];
    return `${nomSimple} ${prenomSimple}`.trim();
  }

  console.log('✅ GroupsModule - Utilise simplifierNomComplet VERSION 4.3 globale');

  // ═══════════════════════════════════════════════════════════════
  //  CRÉATION DE LA MODAL
  // ═══════════════════════════════════════════════════════════════

  function createModal() {
    closeModal();

    const overlay = documentRef.createElement('div');
    overlay.className = 'fixed inset-0 z-[9998] flex items-center justify-center bg-slate-900/70 px-4 animate-fade-in';
    overlay.dataset.groupsModal = 'complete';

    const panel = documentRef.createElement('div');
    panel.className = 'bg-white rounded-3xl shadow-2xl w-full max-w-[95vw] max-h-[95vh] overflow-hidden flex flex-col';

    panel.innerHTML = `
      <header class="px-8 pt-8 pb-6 border-b border-slate-200 bg-gradient-to-br from-indigo-50 via-white to-purple-50">
        <div class="flex items-start justify-between gap-6 mb-6">
          <div class="flex items-center gap-4">
            <div class="h-14 w-14 rounded-2xl bg-gradient-to-br ${state.groupType ? GROUP_TYPES[state.groupType].color : 'from-slate-400 to-slate-600'} flex items-center justify-center text-3xl shadow-lg">
              ${state.groupType ? GROUP_TYPES[state.groupType].icon : '✨'}
            </div>
            <div>
              <h2 class="text-2xl font-bold text-slate-900">Création de Groupes</h2>
              <p class="text-sm text-slate-600 mt-1">
                ${state.groupType ? GROUP_TYPES[state.groupType].title : 'Assistant intelligent de création de groupes'}
              </p>
            </div>
          </div>
          <button type="button" class="text-slate-400 hover:text-slate-600 transition-colors p-2" data-action="close">
            <i class="fas fa-times text-2xl"></i>
          </button>
        </div>

        <nav class="flex items-center gap-2" data-stepper>
          ${[1, 2, 3, 4, 5].map(step => `
            <div class="flex items-center gap-2 flex-1">
              <div class="stepper-step ${step <= state.currentStep ? 'active' : ''} ${step === state.currentStep ? 'current' : ''}" data-step="${step}">
                <span class="step-number">${step}</span>
                <span class="step-label">${getStepLabel(step)}</span>
              </div>
              ${step < 5 ? '<div class="step-connector"></div>' : ''}
            </div>
          `).join('')}
        </nav>
      </header>

      <div class="flex-1 overflow-y-auto px-8 py-8" data-step-container>
        ${renderStepContent()}
      </div>

      <footer class="border-t border-slate-200 bg-slate-50 px-8 py-5 flex items-center justify-between gap-4">
        <div class="flex items-center gap-3 text-sm text-slate-600" data-footer-info>
          ${getFooterInfo()}
        </div>
        <div class="flex items-center gap-3">
          <button type="button" class="px-5 py-2.5 rounded-xl bg-slate-200 hover:bg-slate-300 text-slate-700 font-semibold transition-colors" data-action="secondary">
            ${getSecondaryButtonLabel()}
          </button>
          <button type="button" class="px-5 py-2.5 rounded-xl bg-gradient-to-r ${state.groupType ? GROUP_TYPES[state.groupType].color : 'from-indigo-600 to-purple-600'} text-white font-semibold shadow-lg hover:shadow-xl transition-all" data-action="primary">
            ${getPrimaryButtonLabel()}
          </button>
        </div>
      </footer>
    `;

    overlay.appendChild(panel);
    documentRef.body.appendChild(overlay);
    state.modal = overlay;

    // Event listeners
    overlay.addEventListener('click', (e) => {
      if (e.target === overlay) closeModal();
    });

    attachEventListeners();

    return overlay;
  }

  function closeModal() {
    if (state.modal) {
      state.modal.remove();
      state.modal = null;
    }
    // Nettoyer les sortables
    state.sortables.forEach(sortable => {
      try {
        sortable.destroy();
      } catch (e) {}
    });
    state.sortables = [];
  }

  function getStepLabel(step) {
    const labels = {
      1: 'Type',
      2: 'Classes',
      3: 'Config',
      4: 'Aperçu',
      5: 'Groupes'
    };
    return labels[step] || '';
  }

  function getFooterInfo() {
    if (state.currentStep === 5 && state.lastGeneration) {
      return `<i class="fas fa-clock"></i> Généré le ${formatDate(state.lastGeneration)}`;
    }
    if (state.selectedClasses.length > 0) {
      return `<i class="fas fa-users"></i> ${state.selectedClasses.length} classe(s) sélectionnée(s)`;
    }
    return '<i class="fas fa-info-circle"></i> Suivez les étapes pour créer vos groupes';
  }

  function getSecondaryButtonLabel() {
    if (state.currentStep === 1) return 'Fermer';
    if (state.currentStep === 5) return 'Recommencer';
    return 'Précédent';
  }

  function getPrimaryButtonLabel() {
    if (state.currentStep === 4) return 'Générer les groupes';
    if (state.currentStep === 5) return 'Fermer';
    return 'Continuer';
  }

  // ═══════════════════════════════════════════════════════════════
  //  RENDU DES ÉTAPES
  // ═══════════════════════════════════════════════════════════════

  function renderStepContent() {
    switch (state.currentStep) {
      case 1: return renderStep1_ChooseType();
      case 2: return renderStep2_SelectClasses();
      case 3: return renderStep3_Configure();
      case 4: return renderStep4_Preview();
      case 5: return renderStep5_Groups();
      default: return '<p class="text-center text-slate-500">Étape inconnue</p>';
    }
  }

  // ─────────────────────────────────────────────────────────────
  //  ÉTAPE 1 : Choix du type de groupes
  // ─────────────────────────────────────────────────────────────

  function renderStep1_ChooseType() {
    return `
      <div class="max-w-5xl mx-auto">
        <div class="text-center mb-10">
          <h3 class="text-3xl font-bold text-slate-900 mb-3">Quel type de groupes souhaitez-vous créer ?</h3>
          <p class="text-lg text-slate-600">Choisissez le mode de répartition adapté à vos besoins pédagogiques</p>
        </div>

        <div class="grid md:grid-cols-3 gap-6">
          ${Object.values(GROUP_TYPES).map(type => `
            <button
              type="button"
              class="group-type-card ${state.groupType === type.id ? 'selected' : ''} ${type.disabled ? 'disabled' : ''}"
              data-type="${type.id}"
              ${type.disabled ? 'disabled' : ''}
            >
              <div class="icon-wrapper">
                <div class="icon">${type.icon}</div>
              </div>
              <h4 class="title">${type.title}</h4>
              <p class="description">${type.description}</p>
              ${type.disabled ? '<span class="badge-disabled">Bientôt disponible</span>' : ''}
              ${state.groupType === type.id ? '<i class="fas fa-check-circle check-icon"></i>' : ''}
            </button>
          `).join('')}
        </div>

        <div class="grid md:grid-cols-2 gap-6 mt-10">
          <div class="info-card ${GROUP_TYPES.needs.bgColor} ${GROUP_TYPES.needs.borderColor}">
            <div class="flex items-start gap-4">
              <div class="text-4xl">${GROUP_TYPES.needs.icon}</div>
              <div>
                <h5 class="font-semibold text-slate-900 mb-2">Groupes de Besoins</h5>
                <ul class="text-sm text-slate-700 space-y-1">
                  <li><i class="fas fa-check text-blue-600 mr-2"></i>Scores Math/Français</li>
                  <li><i class="fas fa-check text-blue-600 mr-2"></i>Critères COM, TRA, PART, ABS</li>
                  <li><i class="fas fa-check text-blue-600 mr-2"></i>Groupes hétérogènes</li>
                  <li><i class="fas fa-check text-blue-600 mr-2"></i>Parité F/M équilibrée</li>
                </ul>
              </div>
            </div>
          </div>

          <div class="info-card ${GROUP_TYPES.language.bgColor} ${GROUP_TYPES.language.borderColor}">
            <div class="flex items-start gap-4">
              <div class="text-4xl">${GROUP_TYPES.language.icon}</div>
              <div>
                <h5 class="font-semibold text-slate-900 mb-2">Groupes LV2</h5>
                <ul class="text-sm text-slate-700 space-y-1">
                  <li><i class="fas fa-check text-purple-600 mr-2"></i>ESP / ITA / autres langues</li>
                  <li><i class="fas fa-check text-purple-600 mr-2"></i>Priorité à PART (participation)</li>
                  <li><i class="fas fa-check text-purple-600 mr-2"></i>Critères COM, TRA, ABS</li>
                  <li><i class="fas fa-check text-purple-600 mr-2"></i>Parité F/M équilibrée</li>
                </ul>
              </div>
            </div>
          </div>
        </div>
      </div>
    `;
  }

  // ─────────────────────────────────────────────────────────────
  //  ÉTAPE 2 : Sélection des classes
  // ─────────────────────────────────────────────────────────────

  function renderStep2_SelectClasses() {
    if (state.isLoading) {
      return `
        <div class="flex flex-col items-center justify-center py-20">
          <div class="spinner-large mb-6"></div>
          <p class="text-lg text-slate-600">Chargement des classes disponibles...</p>
          <p class="text-sm text-slate-500 mt-2">Lecture des onglets avec suffixe FIN</p>
        </div>
      `;
    }

    if (state.loadError) {
      return `
        <div class="flex flex-col items-center justify-center py-20">
          <i class="fas fa-circle-exclamation text-6xl text-red-500 mb-6"></i>
          <p class="text-lg text-red-600 font-semibold mb-2">Erreur de chargement</p>
          <p class="text-sm text-slate-600 mb-6">${state.loadError}</p>
          <button type="button" class="px-6 py-3 rounded-xl bg-red-100 hover:bg-red-200 text-red-700 font-semibold transition-colors" data-action="retry-load">
            <i class="fas fa-rotate-right mr-2"></i>Réessayer
          </button>
        </div>
      `;
    }

    return `
      <div class="max-w-4xl mx-auto">
        <div class="text-center mb-8">
          <h3 class="text-2xl font-bold text-slate-900 mb-3">Sélectionnez les classes à regrouper</h3>
          <p class="text-slate-600">Choisissez les classes qui participeront à la création des groupes</p>
        </div>

        <div class="bg-slate-50 rounded-2xl p-6 mb-6">
          <div class="flex items-center justify-between mb-4">
            <span class="text-sm font-semibold text-slate-700">
              <i class="fas fa-check-double mr-2"></i>${state.selectedClasses.length} classe(s) sélectionnée(s)
            </span>
            <div class="flex gap-2">
              <button type="button" class="px-4 py-2 rounded-lg bg-white hover:bg-slate-100 text-slate-700 text-sm font-medium transition-colors border border-slate-200" data-action="select-all-classes">
                Tout sélectionner
              </button>
              <button type="button" class="px-4 py-2 rounded-lg bg-white hover:bg-slate-100 text-slate-700 text-sm font-medium transition-colors border border-slate-200" data-action="deselect-all-classes">
                Tout désélectionner
              </button>
            </div>
          </div>

          <div class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-3">
            ${state.availableClasses.length === 0 ? `
              <div class="col-span-full text-center py-8 text-slate-500">
                <i class="fas fa-inbox text-4xl mb-3"></i>
                <p>Aucune classe avec suffixe FIN trouvée</p>
                <p class="text-sm mt-2">Vérifiez que vos onglets sont nommés correctement (ex: 6°1FIN)</p>
              </div>
            ` : state.availableClasses.map(classe => `
              <label class="class-checkbox-card ${state.selectedClasses.includes(classe) ? 'selected' : ''}">
                <input
                  type="checkbox"
                  class="class-checkbox"
                  value="${classe}"
                  ${state.selectedClasses.includes(classe) ? 'checked' : ''}
                >
                <span class="class-name">${classe}</span>
                <i class="fas fa-check check-icon"></i>
              </label>
            `).join('')}
          </div>
        </div>

        <div class="bg-blue-50 border border-blue-200 rounded-xl p-4 flex items-start gap-3">
          <i class="fas fa-lightbulb text-blue-600 text-xl mt-0.5"></i>
          <div class="text-sm text-blue-900">
            <p class="font-semibold mb-1">Conseil :</p>
            <p>Regroupez des classes de même niveau pour des groupes cohérents. Exemple : <strong>5°1 + 5°2 + 5°3</strong></p>
          </div>
        </div>
      </div>
    `;
  }

  // ─────────────────────────────────────────────────────────────
  //  ÉTAPE 3 : Configuration
  // ─────────────────────────────────────────────────────────────

  function renderStep3_Configure() {
    const isNeeds = state.groupType === 'needs';
    const isLanguage = state.groupType === 'language';

    return `
      <div class="max-w-3xl mx-auto">
        <div class="text-center mb-8">
          <h3 class="text-2xl font-bold text-slate-900 mb-3">Configuration des groupes</h3>
          <p class="text-slate-600">Définissez les paramètres de génération</p>
        </div>

        <div class="config-card mb-6">
          <div class="config-header">
            <i class="fas fa-layer-group text-2xl text-indigo-600"></i>
            <div>
              <h4 class="font-semibold text-slate-900">Nombre de groupes</h4>
              <p class="text-sm text-slate-600">Combien de groupes voulez-vous créer ?</p>
            </div>
          </div>
          <div class="config-body">
            <div class="flex items-center gap-6">
              <input
                type="range"
                min="1"
                max="10"
                value="${state.numGroups}"
                class="flex-1 accent-indigo-600"
                data-input="numGroups"
              >
              <div class="flex items-center gap-3">
                <button type="button" class="number-btn" data-action="decrement-groups">
                  <i class="fas fa-minus"></i>
                </button>
                <span class="number-display" data-display="numGroups">${state.numGroups}</span>
                <button type="button" class="number-btn" data-action="increment-groups">
                  <i class="fas fa-plus"></i>
                </button>
              </div>
            </div>
          </div>
        </div>

        ${isNeeds ? `
          <div class="config-card mb-6">
            <div class="config-header">
              <i class="fas fa-chart-line text-2xl text-blue-600"></i>
              <div>
                <h4 class="font-semibold text-slate-900">Matière de référence</h4>
                <p class="text-sm text-slate-600">Sur quels scores baser la répartition ?</p>
              </div>
            </div>
            <div class="config-body">
              <div class="grid grid-cols-1 gap-3">
                ${Object.values(SUBJECTS).map(subject => `
                  <label class="radio-card ${state.selectedSubject === subject.id ? 'selected' : ''}">
                    <input
                      type="radio"
                      name="subject"
                      value="${subject.id}"
                      ${state.selectedSubject === subject.id ? 'checked' : ''}
                    >
                    <div class="flex items-center gap-3">
                      <span class="text-2xl">${subject.icon}</span>
                      <span class="font-medium">${subject.label}</span>
                    </div>
                    <i class="fas fa-check-circle check-icon"></i>
                  </label>
                `).join('')}
              </div>
            </div>
          </div>

          <div class="config-card mb-6">
            <div class="config-header">
              <i class="fas fa-shuffle text-2xl text-purple-600"></i>
              <div>
                <h4 class="font-semibold text-slate-900">Type de répartition</h4>
                <p class="text-sm text-slate-600">Comment mélanger les niveaux ?</p>
              </div>
            </div>
            <div class="config-body">
              <div class="grid grid-cols-1 gap-3">
                ${Object.values(DISTRIBUTION_TYPES).map(dist => `
                  <label class="radio-card ${state.distributionType === dist.id ? 'selected' : ''}">
                    <input
                      type="radio"
                      name="distribution"
                      value="${dist.id}"
                      ${state.distributionType === dist.id ? 'checked' : ''}
                    >
                    <div class="flex-1">
                      <span class="font-medium">${dist.label}</span>
                      ${dist.recommended ? '<span class="badge-recommended ml-2">Recommandé</span>' : ''}
                    </div>
                    <i class="fas fa-check-circle check-icon"></i>
                  </label>
                `).join('')}
              </div>
            </div>
          </div>
        ` : ''}

        ${isLanguage ? `
          <div class="config-card mb-6">
            <div class="config-header">
              <i class="fas fa-language text-2xl text-purple-600"></i>
              <div>
                <h4 class="font-semibold text-slate-900">Langue à répartir</h4>
                <p class="text-sm text-slate-600">Quelle LV2 souhaitez-vous regrouper ?</p>
              </div>
            </div>
            <div class="config-body">
              <div class="grid grid-cols-2 gap-3">
                ${['ESP', 'ITA', 'ALL', 'AUTRE'].map(lang => `
                  <label class="radio-card ${state.selectedLanguage === lang ? 'selected' : ''}">
                    <input
                      type="radio"
                      name="language"
                      value="${lang}"
                      ${state.selectedLanguage === lang ? 'checked' : ''}
                    >
                    <div class="flex items-center gap-2">
                      <span class="font-medium">${lang === 'ESP' ? 'Espagnol' : lang === 'ITA' ? 'Italien' : lang === 'ALL' ? 'Allemand' : 'Autre'}</span>
                      ${lang === 'ESP' ? '<span class="text-xl">🇪🇸</span>' : lang === 'ITA' ? '<span class="text-xl">🇮🇹</span>' : lang === 'ALL' ? '<span class="text-xl">🇩🇪</span>' : '<span class="text-xl">🌍</span>'}
                    </div>
                    <i class="fas fa-check-circle check-icon"></i>
                  </label>
                `).join('')}
              </div>
            </div>
          </div>

          <div class="bg-purple-50 border border-purple-200 rounded-xl p-4 flex items-start gap-3">
            <i class="fas fa-info-circle text-purple-600 text-xl mt-0.5"></i>
            <div class="text-sm text-purple-900">
              <p class="font-semibold mb-1">À propos de la langue :</p>
              <p>Les élèves de la langue sélectionnée seront répartis en <strong>${state.numGroups} groupe(s)</strong>. La <strong>participation (PART)</strong> sera le critère prioritaire.</p>
            </div>
          </div>
        ` : ''}
      </div>
    `;
  }

  // ─────────────────────────────────────────────────────────────
  //  ÉTAPE 4 : Aperçu avant génération
  // ─────────────────────────────────────────────────────────────

  function renderStep4_Preview() {
    const config = getConfigSummary();

    return `
      <div class="max-w-4xl mx-auto">
        <div class="text-center mb-8">
          <h3 class="text-2xl font-bold text-slate-900 mb-3">Récapitulatif de la configuration</h3>
          <p class="text-slate-600">Vérifiez les paramètres avant de générer les groupes</p>
        </div>

        <div class="grid md:grid-cols-2 gap-6 mb-8">
          <div class="summary-card">
            <div class="summary-icon ${GROUP_TYPES[state.groupType].color}">
              ${GROUP_TYPES[state.groupType].icon}
            </div>
            <div>
              <p class="summary-label">Type de groupes</p>
              <p class="summary-value">${GROUP_TYPES[state.groupType].title}</p>
            </div>
          </div>

          <div class="summary-card">
            <div class="summary-icon bg-gradient-to-br from-indigo-600 to-purple-600">
              <i class="fas fa-layer-group"></i>
            </div>
            <div>
              <p class="summary-label">Nombre de groupes</p>
              <p class="summary-value">${state.numGroups} groupe(s)</p>
            </div>
          </div>

          <div class="summary-card md:col-span-2">
            <div class="summary-icon bg-gradient-to-br from-emerald-600 to-teal-600">
              <i class="fas fa-school"></i>
            </div>
            <div class="flex-1">
              <p class="summary-label">Classes sélectionnées</p>
              <p class="summary-value">${state.selectedClasses.length} classe(s)</p>
              <div class="flex flex-wrap gap-2 mt-2">
                ${state.selectedClasses.map(c => `
                  <span class="px-3 py-1 bg-slate-100 text-slate-700 rounded-lg text-sm font-medium">${c}</span>
                `).join('')}
              </div>
            </div>
          </div>

          ${config.map(item => `
            <div class="summary-card">
              <div class="summary-icon ${item.color}">
                <i class="fas ${item.icon}"></i>
              </div>
              <div>
                <p class="summary-label">${item.label}</p>
                <p class="summary-value">${item.value}</p>
              </div>
            </div>
          `).join('')}
        </div>

        <div class="bg-gradient-to-br from-slate-50 to-slate-100 rounded-2xl p-6 border border-slate-200">
          <h4 class="font-semibold text-slate-900 mb-4 flex items-center gap-2">
            <i class="fas fa-list-check text-indigo-600"></i>
            Critères de répartition appliqués
          </h4>
          <div class="grid md:grid-cols-2 gap-3">
            ${getCriteriaList().map(criterion => `
              <div class="flex items-center gap-2 text-sm text-slate-700">
                <i class="fas fa-check-circle text-green-600"></i>
                <span>${criterion}</span>
              </div>
            `).join('')}
          </div>
        </div>

        <div class="mt-6 bg-amber-50 border border-amber-200 rounded-xl p-4 flex items-start gap-3">
          <i class="fas fa-triangle-exclamation text-amber-600 text-xl mt-0.5"></i>
          <div class="text-sm text-amber-900">
            <p class="font-semibold mb-1">Attention :</p>
            <p>La génération peut prendre quelques secondes selon le nombre d'élèves. L'algorithme optimise la répartition pour respecter tous les critères.</p>
          </div>
        </div>
      </div>
    `;
  }

  function getConfigSummary() {
    const items = [];

    if (state.groupType === 'needs') {
      items.push({
        label: 'Matière de référence',
        value: SUBJECTS[state.selectedSubject].label,
        icon: 'fa-chart-line',
        color: 'bg-gradient-to-br from-blue-600 to-indigo-600'
      });
      items.push({
        label: 'Type de répartition',
        value: DISTRIBUTION_TYPES[state.distributionType].label,
        icon: 'fa-shuffle',
        color: 'bg-gradient-to-br from-purple-600 to-pink-600'
      });
    }

    if (state.groupType === 'language') {
      const langLabels = { ESP: 'Espagnol', ITA: 'Italien', ALL: 'Allemand', AUTRE: 'Autre' };
      items.push({
        label: 'Langue ciblée',
        value: langLabels[state.selectedLanguage] || state.selectedLanguage,
        icon: 'fa-language',
        color: 'bg-gradient-to-br from-purple-600 to-pink-600'
      });
    }

    return items;
  }

  function getCriteriaList() {
    const base = [
      'Parité Filles/Garçons équilibrée',
      'Effectifs harmonisés (±1-2 élèves)',
      'Critères COM, TRA, PART, ABS'
    ];

    if (state.groupType === 'needs') {
      return [
        'Scores Math/Français (groupes hétérogènes)',
        ...base,
        'Tous niveaux mélangés dans chaque groupe'
      ];
    }

    if (state.groupType === 'language') {
      return [
        'Participation (PART) - Critère prioritaire',
        ...base,
        'Répartition équilibrée par langue'
      ];
    }

    return base;
  }

  // ─────────────────────────────────────────────────────────────
  //  ÉTAPE 5 : Affichage des groupes avec Drag & Drop
  // ─────────────────────────────────────────────────────────────

  function renderStep5_Groups() {
    if (state.isLoading) {
      return `
        <div class="flex flex-col items-center justify-center py-20">
          <div class="spinner-large mb-6"></div>
          <p class="text-lg text-slate-600 font-semibold">Génération des groupes en cours...</p>
          <p class="text-sm text-slate-500 mt-2">L'algorithme optimise la répartition</p>
          <div class="mt-6 flex items-center gap-2 text-xs text-slate-400">
            <div class="w-2 h-2 bg-indigo-500 rounded-full animate-pulse"></div>
            <div class="w-2 h-2 bg-purple-500 rounded-full animate-pulse delay-100"></div>
            <div class="w-2 h-2 bg-pink-500 rounded-full animate-pulse delay-200"></div>
          </div>
        </div>
      `;
    }

    if (!state.generatedGroups || state.generatedGroups.length === 0) {
      return `
        <div class="flex flex-col items-center justify-center py-20">
          <i class="fas fa-inbox text-6xl text-slate-300 mb-6"></i>
          <p class="text-lg text-slate-600">Aucun groupe généré</p>
          <button type="button" class="mt-6 px-6 py-3 rounded-xl bg-indigo-600 hover:bg-indigo-700 text-white font-semibold transition-colors" data-action="regenerate">
            <i class="fas fa-rotate-right mr-2"></i>Générer maintenant
          </button>
        </div>
      `;
    }

    // LAYOUT : Adapter le nombre de colonnes selon le nombre de groupes
    // Objectif : maximiser la HAUTEUR verticale de chaque groupe pour plus de swaps
    // - 1-3 groupes : autant de colonnes (côte à côte)
    // - 4 groupes : 2 colonnes (2x2 grid)
    // - 5-6 groupes : 3 colonnes (max) pour garder hauteur
    // - 7+ groupes : 3 colonnes + scroll horizontal
    const groupCount = state.generatedGroups.length;
    let gridClass = '';

    if (groupCount <= 3) {
      gridClass = `grid-cols-${groupCount}`; // 1, 2 ou 3 colonnes selon le nombre
    } else if (groupCount === 4) {
      gridClass = 'grid-cols-2'; // 2x2 grid
    } else if (groupCount <= 6) {
      gridClass = 'grid-cols-3'; // 3 colonnes max pour garder hauteur
    } else {
      gridClass = 'grid-cols-3'; // 3 colonnes + scroll pour 7+
    }

    return `
      <div class="flex flex-col h-full">
        <div class="flex-shrink-0 mb-6">
          <div class="flex items-center justify-between">
            <div>
              <h3 class="text-2xl font-bold text-slate-900">Groupes générés</h3>
              <p class="text-sm text-slate-600 mt-1">
                ${state.generatedGroups.length} groupe(s) • ${getTotalStudents()} élèves répartis
              </p>
            </div>
            <div class="flex items-center gap-3 flex-wrap justify-end">
              <!-- Mode de sauvegarde: Remplacer ou Ajouter -->
              <div class="flex items-center gap-2 bg-slate-100 p-2 rounded-lg">
                <button type="button" class="action-btn ${state.saveMode === 'replace' ? 'bg-red-600 text-white' : 'bg-slate-200 text-slate-700'}" data-action="set-save-mode" data-mode="replace" title="Remplacer: supprime les groupes précédents du même type">
                  <i class="fas fa-arrows-rotate"></i>
                  Remplacer
                </button>
                <button type="button" class="action-btn ${state.saveMode === 'append' ? 'bg-green-600 text-white' : 'bg-slate-200 text-slate-700'}" data-action="set-save-mode" data-mode="append" title="Ajouter: cumule avec les groupes existants">
                  <i class="fas fa-plus-circle"></i>
                  Ajouter
                </button>
              </div>

              <button type="button" class="action-btn ${state.showStatistics ? 'bg-indigo-600 text-white' : 'bg-slate-100 text-slate-700'} hover:bg-indigo-700" data-action="toggle-statistics">
                <i class="fas fa-chart-bar"></i>
                Statistiques
              </button>
              <button type="button" class="action-btn bg-slate-100 hover:bg-slate-200 text-slate-700" data-action="regenerate">
                <i class="fas fa-rotate-right"></i>
                Régénérer
              </button>
              <button type="button" class="action-btn bg-blue-100 hover:bg-blue-200 text-blue-700" data-action="export-pdf">
                <i class="fas fa-file-pdf"></i>
                PDF
              </button>
              <button type="button" class="action-btn bg-green-100 hover:bg-green-200 text-green-700" data-action="export-csv">
                <i class="fas fa-file-csv"></i>
                CSV
              </button>
              <button type="button" class="action-btn bg-yellow-100 hover:bg-yellow-200 text-yellow-700" data-action="load-temp-groups" title="Charger les groupes temporaires sauvegardés">
                <i class="fas fa-download"></i>
                📥 Charger
              </button>
              <button type="button" class="action-btn bg-orange-600 hover:bg-orange-700 text-white" data-action="save-temp-groups" title="Sauvegarder les groupes en version temporaire (cachée)">
                <i class="fas fa-save"></i>
                💾 Temp
              </button>
              <button type="button" class="action-btn bg-green-600 hover:bg-green-700 text-white" data-action="finalize-temp-groups" title="Finaliser : convertir gr*TEMP en gr* (visibles)">
                <i class="fas fa-check-circle"></i>
                ✅ Finaliser
              </button>
            </div>
          </div>
        </div>

        <!-- Contenu flexible et scrollable -->
        <div class="flex-1 overflow-y-auto">
          <div class="flex gap-6">
            <div class="${state.showStatistics ? 'flex-1' : 'w-full'}">
              <div class="grid ${gridClass} gap-4" id="groups-container">
                ${state.generatedGroups.map((group, index) => renderGroupCard(group, index)).join('')}
              </div>
            </div>

            ${state.showStatistics ? renderStatisticsPanel() : ''}
          </div>
        </div>

        <!-- Info fixe en bas -->
        <div class="flex-shrink-0 mt-6 bg-indigo-50 border border-indigo-200 rounded-xl p-4 flex items-start gap-3">
          <i class="fas fa-hand-pointer text-indigo-600 text-xl mt-0.5"></i>
          <div class="text-sm text-indigo-900">
            <p class="font-semibold mb-1">Glisser-déposer activé :</p>
            <p>Vous pouvez réorganiser les élèves en les déplaçant d'un groupe à l'autre. Les statistiques se mettent à jour automatiquement.</p>
          </div>
        </div>
      </div>
    `;
  }

  function renderGroupCard(group, index) {
    const stats = calculateGroupStats(group);

    return `
      <div class="group-card" data-group-index="${index}">
        <div class="group-header ${GROUP_TYPES[state.groupType].color}">
          <h4 class="group-title">${group.name || `Groupe ${index + 1}`}</h4>
          <span class="group-count">${group.students.length} élèves</span>
        </div>

        <div class="group-stats">
          <div class="stat-item">
            <i class="fas fa-venus-mars text-pink-600"></i>
            <span>${stats.girls}F / ${stats.boys}M</span>
          </div>
          ${state.groupType === 'needs' ? `
            <div class="stat-item">
              <i class="fas fa-chart-line text-blue-600"></i>
              <span>Moy: ${stats.avgScore}</span>
            </div>
          ` : ''}
          ${state.groupType === 'language' ? `
            <div class="stat-item">
              <i class="fas fa-comments text-purple-600"></i>
              <span>PART: ${stats.avgPart}</span>
            </div>
          ` : ''}
        </div>

        <div class="group-students" data-group-id="${index}">
          ${group.students.map(student => renderStudentCard(student)).join('')}
        </div>
      </div>
    `;
  }

  function renderStudentCard(student) {
    const nomAffiche = simplifierNomComplet(student.nom, student.prenom);

    // Déterminer si l'élève a un score COM = 1 (besoin d'attention)
    const comScore = student.scores?.COM ?? student.com ?? 0;
    const isComRed = comScore === 1;
    const nameClass = isComRed ? 'text-red-600 font-semibold' : '';

    return `
      <div class="student-card" data-student-id="${student.id}" data-source="${student.source || ''}">
        <span class="student-sexe ${student.sexe === 'F' ? 'sexe-f' : 'sexe-m'}" title="${student.sexe}">${student.sexe || '?'}</span>
        <div style="flex: 1; min-width: 0; display: flex; flex-direction: column; gap: 0.125rem;">
          <p class="student-name ${nameClass}" title="${nomAffiche}">${nomAffiche}</p>
          <div style="display: flex; gap: 0.25rem; font-size: 0.65rem; color: #64748b;">
            <span title="Classe FIN">${student.classe || '—'}</span>
            ${student.source ? `<span title="Classe origine">| ${student.source}</span>` : ''}
          </div>
        </div>
        ${renderStudentScores(student)}
        <i class="fas fa-grip-vertical text-slate-300 drag-handle" style="flex-shrink: 0; font-size: 0.7rem;"></i>
      </div>
    `;
  }

  function renderStudentScores(student) {
    if (state.groupType === 'needs') {
      const scoreF = student.scores?.F || 0;
      const scoreM = student.scores?.M || 0;
      const avg = ((scoreF + scoreM) / 2).toFixed(1);
      return `
        <div class="student-scores">
          <span class="score-badge">📚 ${scoreF}</span>
          <span class="score-badge">📐 ${scoreM}</span>
          <span class="score-badge avg">Moy ${avg}</span>
        </div>
      `;
    }

    if (state.groupType === 'language') {
      const part = student.part || student.scores?.PART || 0;
      return `
        <div class="student-scores">
          <span class="score-badge">${student.lv2 || '—'}</span>
          <span class="score-badge">PART: ${part}</span>
        </div>
      `;
    }

    return '';
  }

  function calculateGroupStats(group) {
    let girls = 0, boys = 0, totalScoreF = 0, totalScoreM = 0, totalPart = 0;

    group.students.forEach(student => {
      if (student.sexe === 'F') girls++;
      if (student.sexe === 'M') boys++;
      totalScoreF += student.scores?.F || 2.5;
      totalScoreM += student.scores?.M || 2.5;
      totalPart += student.part || student.scores?.PART || 0;
    });

    const count = group.students.length || 1;

    return {
      girls,
      boys,
      avgScore: ((totalScoreF + totalScoreM) / (count * 2)).toFixed(1),
      avgPart: (totalPart / count).toFixed(1)
    };
  }

  function getTotalStudents() {
    return state.generatedGroups.reduce((sum, group) => sum + group.students.length, 0);
  }

  // ═══════════════════════════════════════════════════════════════
  //  PANNEAU STATISTIQUES
  // ═══════════════════════════════════════════════════════════════

  function renderStatisticsPanel() {
    return `
      <div class="statistics-panel w-96">
        <div class="bg-white rounded-2xl border-2 border-slate-200 overflow-hidden sticky top-4">
          <div class="bg-gradient-to-br from-indigo-600 to-purple-600 text-white p-4">
            <h4 class="font-bold text-lg flex items-center gap-2">
              <i class="fas fa-chart-pie"></i>
              Distribution des scores
            </h4>
            <p class="text-sm opacity-90 mt-1">Analyse par groupe</p>
          </div>

          <div class="max-h-[calc(100vh-240px)] overflow-y-auto p-4">
            ${state.generatedGroups.map((group, index) => renderGroupStatistics(group, index)).join('')}
          </div>
        </div>
      </div>
    `;
  }

  function renderGroupStatistics(group, index) {
    const stats = calculateGroupStats(group);
    const scoreDistribution = calculateScoreDistribution(group);

    return `
      <div class="mb-4 last:mb-0">
        <div class="bg-slate-50 rounded-xl p-3 border border-slate-200">
          <div class="flex items-center justify-between mb-3">
            <h5 class="font-semibold text-slate-900">${group.name || `Groupe ${index + 1}`}</h5>
            <span class="text-xs bg-slate-200 text-slate-700 px-2 py-1 rounded-full font-medium">${group.students.length}</span>
          </div>

          <div class="mb-3 pb-3 border-b border-slate-200">
            <div class="flex items-center justify-between text-sm">
              <span class="text-slate-600">Parité</span>
              <span class="font-semibold text-slate-900">${stats.girls}F / ${stats.boys}M</span>
            </div>
          </div>

          ${state.groupType === 'needs' ? `
            <div class="space-y-2">
              <div class="text-xs font-semibold text-slate-700 uppercase tracking-wide mb-2">Distribution Français</div>
              ${renderScoreDistributionBars(scoreDistribution.F, 'F')}

              <div class="text-xs font-semibold text-slate-700 uppercase tracking-wide mb-2 mt-3">Distribution Maths</div>
              ${renderScoreDistributionBars(scoreDistribution.M, 'M')}

              <div class="mt-3 pt-3 border-t border-slate-200">
                <div class="text-xs font-semibold text-slate-700 uppercase tracking-wide mb-2">Critères</div>
                ${renderBehavioralCriteria(group)}
              </div>
            </div>
          ` : ''}

          ${state.groupType === 'language' ? `
            <div class="space-y-2">
              <div class="flex items-center justify-between text-sm">
                <span class="text-slate-600">Participation moy.</span>
                <span class="font-semibold text-purple-700">${stats.avgPart}</span>
              </div>
            </div>
          ` : ''}
        </div>
      </div>
    `;
  }

  function calculateScoreDistribution(group) {
    const distribution = {
      F: { 1: 0, 2: 0, 3: 0, 4: 0 },
      M: { 1: 0, 2: 0, 3: 0, 4: 0 }
    };

    group.students.forEach(student => {
      const scoreF = Math.round(student.scores?.F || 2.5);
      const scoreM = Math.round(student.scores?.M || 2.5);

      // Clamp scores entre 1 et 4
      const clampedF = Math.max(1, Math.min(4, scoreF));
      const clampedM = Math.max(1, Math.min(4, scoreM));

      distribution.F[clampedF] = (distribution.F[clampedF] || 0) + 1;
      distribution.M[clampedM] = (distribution.M[clampedM] || 0) + 1;
    });

    return distribution;
  }

  function renderScoreDistributionBars(distribution, subject) {
    const total = Object.values(distribution).reduce((a, b) => a + b, 0) || 1;
    const colors = {
      1: 'bg-red-500',
      2: 'bg-yellow-500',
      3: 'bg-green-400',
      4: 'bg-green-700'
    };

    return `
      <div class="space-y-1.5">
        ${[1, 2, 3, 4].map(score => {
          const count = distribution[score] || 0;
          const percentage = Math.round((count / total) * 100);

          return `
            <div class="flex items-center gap-2">
              <span class="text-xs font-medium text-slate-600 w-8">${subject === 'F' ? '📚' : '📐'} ${score}</span>
              <div class="flex-1 bg-slate-200 rounded-full h-5 overflow-hidden">
                <div class="${colors[score]} h-full flex items-center justify-end pr-2 transition-all" style="width: ${percentage}%">
                  ${count > 0 ? `<span class="text-xs font-bold text-white">${count}</span>` : ''}
                </div>
              </div>
            </div>
          `;
        }).join('')}
      </div>
    `;
  }

  function renderBehavioralCriteria(group) {
    let totalCOM = 0, totalTRA = 0, totalPART = 0, totalABS = 0;
    const count = group.students.length || 1;

    group.students.forEach(student => {
      totalCOM += student.com || 0;
      totalTRA += student.tra || 0;
      totalPART += student.part || 0;
      totalABS += student.abs || 0;
    });

    const avgCOM = (totalCOM / count).toFixed(1);
    const avgTRA = (totalTRA / count).toFixed(1);
    const avgPART = (totalPART / count).toFixed(1);
    const avgABS = (totalABS / count).toFixed(1);

    return `
      <div class="space-y-1.5 text-xs">
        <div class="flex items-center justify-between">
          <span class="text-slate-600">COM (Comportement)</span>
          <span class="font-semibold text-blue-700">${avgCOM}</span>
        </div>
        <div class="flex items-center justify-between">
          <span class="text-slate-600">TRA (Travail)</span>
          <span class="font-semibold text-indigo-700">${avgTRA}</span>
        </div>
        <div class="flex items-center justify-between">
          <span class="text-slate-600">PART (Participation)</span>
          <span class="font-semibold text-purple-700">${avgPART}</span>
        </div>
        <div class="flex items-center justify-between">
          <span class="text-slate-600">ABS (Absences)</span>
          <span class="font-semibold text-pink-700">${avgABS}</span>
        </div>
      </div>
    `;
  }

  function toggleStatistics() {
    state.showStatistics = !state.showStatistics;
    updateUI();
  }

  // ═══════════════════════════════════════════════════════════════
  //  NAVIGATION & EVENT LISTENERS
  // ═══════════════════════════════════════════════════════════════

  function attachEventListeners() {
    if (!state.modal) return;

    // Actions principales
    const primaryBtn = qs('[data-action="primary"]', state.modal);
    const secondaryBtn = qs('[data-action="secondary"]', state.modal);
    const closeBtn = qs('[data-action="close"]', state.modal);

    if (primaryBtn) primaryBtn.onclick = handlePrimaryAction;
    if (secondaryBtn) secondaryBtn.onclick = handleSecondaryAction;
    if (closeBtn) closeBtn.onclick = closeModal;

    // Étape 1 : Sélection du type
    qsa('[data-type]', state.modal).forEach(btn => {
      btn.onclick = () => {
        if (!btn.disabled) {
          selectGroupType(btn.dataset.type);
        }
      };
    });

    // Étape 2 : Sélection des classes
    qsa('.class-checkbox', state.modal).forEach(checkbox => {
      checkbox.onchange = handleClassSelection;
    });

    const selectAllBtn = qs('[data-action="select-all-classes"]', state.modal);
    const deselectAllBtn = qs('[data-action="deselect-all-classes"]', state.modal);
    const retryBtn = qs('[data-action="retry-load"]', state.modal);

    if (selectAllBtn) selectAllBtn.onclick = selectAllClasses;
    if (deselectAllBtn) deselectAllBtn.onclick = deselectAllClasses;
    if (retryBtn) retryBtn.onclick = loadAvailableClasses;

    // Étape 3 : Configuration
    const numGroupsRange = qs('[data-input="numGroups"]', state.modal);
    if (numGroupsRange) {
      numGroupsRange.oninput = (e) => {
        state.numGroups = parseInt(e.target.value);
        const display = qs('[data-display="numGroups"]', state.modal);
        if (display) display.textContent = state.numGroups;
      };
    }

    const incrBtn = qs('[data-action="increment-groups"]', state.modal);
    const decrBtn = qs('[data-action="decrement-groups"]', state.modal);

    if (incrBtn) incrBtn.onclick = () => changeNumGroups(1);
    if (decrBtn) decrBtn.onclick = () => changeNumGroups(-1);

    qsa('input[name="subject"]', state.modal).forEach(radio => {
      radio.onchange = (e) => {
        state.selectedSubject = e.target.value;
        updateUI();
      };
    });

    qsa('input[name="distribution"]', state.modal).forEach(radio => {
      radio.onchange = (e) => {
        state.distributionType = e.target.value;
        updateUI();
      };
    });

    qsa('input[name="language"]', state.modal).forEach(radio => {
      radio.onchange = (e) => {
        state.selectedLanguage = e.target.value;
        updateUI();
      };
    });

    // Étape 5 : Actions sur les groupes
    const toggleStatsBtn = qs('[data-action="toggle-statistics"]', state.modal);
    const regenerateBtn = qs('[data-action="regenerate"]', state.modal);
    const saveModeButtons = qsa('[data-action="set-save-mode"]', state.modal);
    const saveTempBtn = qs('[data-action="save-temp-groups"]', state.modal);
    const loadTempBtn = qs('[data-action="load-temp-groups"]', state.modal);
    const finalizeTempBtn = qs('[data-action="finalize-temp-groups"]', state.modal);
    const exportPdfBtn = qs('[data-action="export-pdf"]', state.modal);
    const exportCsvBtn = qs('[data-action="export-csv"]', state.modal);

    if (toggleStatsBtn) toggleStatsBtn.onclick = toggleStatistics;
    if (regenerateBtn) regenerateBtn.onclick = generateGroups;

    // Handlers pour les boutons de mode (Replace vs Append)
    saveModeButtons.forEach(btn => {
      btn.onclick = (e) => {
        const mode = e.target.closest('button').getAttribute('data-mode');
        state.saveMode = mode;
        updateUI();
        showToast(`Mode: ${mode === 'replace' ? 'Remplacer' : 'Ajouter'}`, 'info');
      };
    });

    if (saveTempBtn) saveTempBtn.onclick = saveTempGroupsUI;
    if (loadTempBtn) loadTempBtn.onclick = loadTempGroupsUI;
    if (finalizeTempBtn) finalizeTempBtn.onclick = finalizeTempGroupsUI;
    if (exportPdfBtn) exportPdfBtn.onclick = exportToPDF;
    if (exportCsvBtn) exportCsvBtn.onclick = exportToCSV;

    // Initialiser Drag & Drop si on est à l'étape 5
    if (state.currentStep === 5 && state.generatedGroups.length > 0) {
      initializeDragAndDrop();
    }
  }

  function handlePrimaryAction() {
    if (state.currentStep === 1) {
      if (!state.groupType) {
        showToast('Veuillez sélectionner un type de groupes', 'warning');
        return;
      }
      nextStep();
    } else if (state.currentStep === 2) {
      if (state.selectedClasses.length === 0) {
        showToast('Veuillez sélectionner au moins une classe', 'warning');
        return;
      }
      nextStep();
    } else if (state.currentStep === 3) {
      nextStep();
    } else if (state.currentStep === 4) {
      generateGroups();
    } else if (state.currentStep === 5) {
      closeModal();
    }
  }

  function handleSecondaryAction() {
    if (state.currentStep === 1) {
      closeModal();
    } else if (state.currentStep === 5) {
      resetToStep1();
    } else {
      previousStep();
    }
  }

  function nextStep() {
    if (state.currentStep < state.totalSteps) {
      state.currentStep++;

      // Charger les classes si on arrive à l'étape 2
      if (state.currentStep === 2 && state.availableClasses.length === 0) {
        loadAvailableClasses();
      }

      updateUI();
    }
  }

  function previousStep() {
    if (state.currentStep > 1) {
      state.currentStep--;
      updateUI();
    }
  }

  function resetToStep1() {
    state.currentStep = 1;
    state.groupType = null;
    state.selectedClasses = [];
    state.generatedGroups = [];
    updateUI();
  }

  function selectGroupType(type) {
    state.groupType = type;
    updateUI();
    // Auto-avancer après sélection
    setTimeout(() => nextStep(), 300);
  }

  function handleClassSelection(e) {
    const classe = e.target.value;
    console.log('[DEBUG] Checkbox clicked:');
    console.log('   value:', classe);
    console.log('   checked:', e.target.checked);
    console.log('   Avant:', state.selectedClasses);

    if (e.target.checked) {
      if (!state.selectedClasses.includes(classe)) {
        state.selectedClasses.push(classe);
        console.log('   ✅ Ajoutée');
      } else {
        console.log('   ⚠️ Déjà présente');
      }
    } else {
      const before = state.selectedClasses.length;
      state.selectedClasses = state.selectedClasses.filter(c => c !== classe);
      const after = state.selectedClasses.length;
      console.log('   ❌ Retirée (avant:', before, 'après:', after, ')');
    }
    console.log('   Après:', state.selectedClasses);
    updateUI();
  }

  function selectAllClasses() {
    console.log('[DEBUG] selectAllClasses() appelée');
    console.log('   availableClasses:', state.availableClasses);
    state.selectedClasses = [...state.availableClasses];
    console.log('   selectedClasses après:', state.selectedClasses);
    updateUI();
  }

  function deselectAllClasses() {
    console.log('[DEBUG] deselectAllClasses() appelée');
    console.log('   Avant:', state.selectedClasses);
    state.selectedClasses = [];
    console.log('   Après:', state.selectedClasses);
    updateUI();
  }

  function changeNumGroups(delta) {
    state.numGroups = Math.max(1, Math.min(10, state.numGroups + delta));
    updateUI();
  }

  function updateUI() {
    if (!state.modal) return;

    // Re-render du contenu
    const container = qs('[data-step-container]', state.modal);
    if (container) {
      container.innerHTML = renderStepContent();
    }

    // Update stepper
    qsa('.stepper-step', state.modal).forEach((step, index) => {
      const stepNum = index + 1;
      step.classList.toggle('active', stepNum <= state.currentStep);
      step.classList.toggle('current', stepNum === state.currentStep);
    });

    // Update footer
    const footerInfo = qs('[data-footer-info]', state.modal);
    const primaryBtn = qs('[data-action="primary"]', state.modal);
    const secondaryBtn = qs('[data-action="secondary"]', state.modal);

    if (footerInfo) footerInfo.innerHTML = getFooterInfo();
    if (primaryBtn) primaryBtn.textContent = getPrimaryButtonLabel();
    if (secondaryBtn) secondaryBtn.textContent = getSecondaryButtonLabel();

    // Update header gradient
    const header = qs('header', state.modal);
    if (header && state.groupType) {
      const iconWrapper = qs('.h-14', header);
      if (iconWrapper) {
        iconWrapper.className = `h-14 w-14 rounded-2xl bg-gradient-to-br ${GROUP_TYPES[state.groupType].color} flex items-center justify-center text-3xl shadow-lg`;
        iconWrapper.textContent = GROUP_TYPES[state.groupType].icon;
      }
    }

    // Re-attach event listeners
    attachEventListeners();
  }

  // ═══════════════════════════════════════════════════════════════
  //  CHARGEMENT DES DONNÉES
  // ═══════════════════════════════════════════════════════════════

  function loadAvailableClasses() {
    console.log('📡 [GroupsModule] Chargement des classes (DOM + backend)...');

    state.isLoading = true;
    state.loadError = null;

    // 1. Snapshot local direct depuis le board visible
    const domSnapshot = snapshotClassesFromDOMForGroups(); // { "6°2": {eleves:[...]}, ... }
    const domClasses = Object.keys(domSnapshot);
    console.log('[GroupsModule] Classes détectées dans le DOM :', domClasses);

    // Cas offline / pas d'Apps Script → on vit uniquement avec le DOM
    if (!google?.script?.run) {
      console.warn('[GroupsModule] google.script.run indisponible → fallback DOM ONLY');
      state.isLoading = false;
      state.classKeyMap = {};
      state.classesData = domSnapshot;           // on stocke DIRECT
      state.availableClasses = domClasses.slice();
      if (!state.selectedClasses.length) {
        state.selectedClasses = domClasses.slice();
      }

      // petit log récap
      let total = 0;
      state.availableClasses.forEach(c => {
        total += (state.classesData[c]?.eleves || []).length;
      });
      console.log(`[GroupsModule] Total d'élèves (DOM only): ${total}`);

      updateUI();
      showToast(`✅ ${domClasses.length} classe(s) détectée(s) / ${total} élève(s)`, 'success');
      return;
    }

    // 2. Sinon, on tente aussi le backend pour compléter les infos
    google.script.run
      .withSuccessHandler(result => {
        console.log('[GroupsModule] Réponse getClassesData:', result);
        state.isLoading = false;

        if (!result || !result.data) {
          console.warn('[GroupsModule] Backend vide ou invalide → on reste 100% DOM');
          finalizeUsingMergedData(domClasses, domSnapshot, {}, {});
          return;
        }

        const backendData = result.data;                 // ex: { "6E2FIN": {eleves:[...]}, ... }
        const backendKeys = Object.keys(backendData);
        console.log('[GroupsModule] Clés brutes renvoyées par getClassesData:', backendKeys);

        // On va essayer de faire correspondre chaque classe affichée ("6°2")
        // avec une clé backend ("6E2FIN") en utilisant canonicalClass().
        const mapping = {};
        const mergedData = {};

        domClasses.forEach(displayName => {
          const domCanon = canonicalClass(displayName);
          console.log(`   🔎 Tentative correspondance pour "${displayName}" (canon: "${domCanon}")`);

          let winnerKey = null;
          for (const k of backendKeys) {
            const kCanon = canonicalClass(k);
            if (
              kCanon === domCanon ||
              kCanon.startsWith(domCanon) ||
              domCanon.startsWith(kCanon)
            ) {
              winnerKey = k;
              break;
            }
          }

          if (winnerKey) {
            console.log(`   ✅ Match backend "${winnerKey}" pour "${displayName}"`);
            mapping[displayName] = winnerKey;

            // priorité backend si présent,
            // sinon on retombe sur le DOM (par cohérence visuelle)
            mergedData[displayName] = backendData[winnerKey] && backendData[winnerKey].eleves
              ? { eleves: backendData[winnerKey].eleves.slice() }
              : (domSnapshot[displayName] || { eleves: [] });

          } else {
            console.warn(`   ⚠️ Pas de correspondance backend pour "${displayName}" → on prend le DOM en source`);
            mapping[displayName] = displayName;
            mergedData[displayName] = domSnapshot[displayName] || { eleves: [] };
          }
        });

        finalizeUsingMergedData(domClasses, mergedData, mapping, backendData);
      })
      .withFailureHandler(error => {
        state.isLoading = false;
        console.error('[GroupsModule] Erreur getClassesData:', error);
        showToast('❌ Erreur backend, utilisation des données visibles à l\'écran', 'warning');

        // backend KO → full DOM
        finalizeUsingMergedData(domClasses, domSnapshot, {}, {});
      })
      .loadFINSheetsWithScores(); // 🔑 Charge les onglets FIN avec SCORE F et SCORE M
  }

  // Helper interne pour factoriser la fin du chargement
  function finalizeUsingMergedData(domClasses, mergedData, mapping, backendData) {
    state.classKeyMap = mapping || {};
    state.classesData = mergedData || {};
    state.availableClasses = domClasses.slice();

    console.log('[DEBUG loadAvailableClasses] Avant auto-sélection:');
    console.log('   selectedClasses:', state.selectedClasses);
    console.log('   availableClasses:', state.availableClasses);

    // Auto-sélection si rien n'est encore choisi
    if (!state.selectedClasses || state.selectedClasses.length === 0) {
      console.log('[DEBUG loadAvailableClasses] Auto-sélection activée (aucune classe préalablement sélectionnée)');
      state.selectedClasses = state.availableClasses.slice();
      console.log('   selectedClasses après auto-sélection:', state.selectedClasses);
    }

    // Compte combien d'élèves on a vraiment
    let totalStudents = 0;
    state.availableClasses.forEach(name => {
      const bucket = state.classesData[name];
      if (bucket && Array.isArray(bucket.eleves)) {
        totalStudents += bucket.eleves.length;
      }
    });

    console.log('[GroupsModule] Mapping affichage→backend:', state.classKeyMap);
    console.log('[GroupsModule] Liste finale des classes pédagogiques:', state.availableClasses);
    console.log('[GroupsModule] selectedClasses au fin de loadAvailableClasses:', state.selectedClasses);
    console.log(`[GroupsModule] Total d'élèves disponibles après fusion DOM/backend: ${totalStudents}`);

    updateUI();

    if (state.availableClasses.length === 0) {
      state.loadError = 'Aucune classe détectée';
      showToast('⚠️ Aucune classe détectée', 'warning');
    } else {
      showToast(
        `✅ ${state.availableClasses.length} classe(s) détectée(s) / ${totalStudents} élève(s)`,
        'success'
      );
    }
  }

  function loadStudentsFromClasses() {
    console.log('[GroupsModule] ════════════════════════════════════════════');
    console.log('[GroupsModule] Chargement des élèves via classesData fusionnée...');
    console.log('[GroupsModule] 🔍 DEBUG - selectedClasses:', state.selectedClasses);
    console.log('[GroupsModule] 🔍 DEBUG - selectedClasses.length:', state.selectedClasses.length);
    console.log('[GroupsModule] 🔍 DEBUG - Clés disponibles dans classesData:', Object.keys(state.classesData));
    console.log('[GroupsModule] 🔍 DEBUG - availableClasses:', state.availableClasses);

    if (!state.classesData || Object.keys(state.classesData).length === 0) {
      showToast('❌ Données des classes non chargées', 'error');
      return Promise.reject('No classes data');
    }

    return new Promise((resolve, reject) => {
      try {
        const students = [];

        (state.selectedClasses || []).forEach(displayName => {
          const bucket = state.classesData[displayName];

          if (!bucket || !Array.isArray(bucket.eleves)) {
            console.warn(`[GroupsModule] ❌ Pas de bucket valide pour "${displayName}"`);
            return;
          }

          console.log(`[GroupsModule] ✅ "${displayName}" : ${bucket.eleves.length} élève(s)`);

          bucket.eleves.forEach((e, idx) => {
            if (!e) return;

            // 1. Récup FR / MATH envoyés par Apps Script
            //    -> e.scoreF et e.scoreM (ex: 11.5 / 8.0)
            const fScore = (typeof e.scoreF === 'number') ? e.scoreF
                         : (typeof e.scores?.F === 'number') ? e.scores.F
                         : null;

            const mScore = (typeof e.scoreM === 'number') ? e.scoreM
                         : (typeof e.scores?.M === 'number') ? e.scores.M
                         : null;

            // 2. Récup comportement / travail / etc.
            const comVal  = (e.com  ?? e.scores?.COM  ?? 0);
            const traVal  = (e.tra  ?? e.scores?.TRA  ?? 0);
            const partVal = (e.part ?? e.scores?.PART ?? 0);
            const absVal  = (e.abs  ?? e.scores?.ABS  ?? 0);

            // 3. Construire l'élève normalisé
            const normalized = {
              // Identité
              id:     e.id || e.ID || e.identifiant || `${displayName}_${idx}`,
              nom:    e.nom || e.NOM || e.lastName || '',
              prenom: e.prenom || e.PRENOM || e.firstName || '',
              sexe:   e.sexe || e.SEXE || e.sex || '',
              classe: displayName,

              // Options et source d'origine
              lv2: e.lv2 || e.LV2 || null,
              opt: e.opt || e.OPT || null,
              source: e.source || e.SOURCE || null,  // classe d'année précédente

              // Scores bruts regroupés
              scores: {
                // ce bloc est ce que les autres fonctions lisent
                F:    (typeof fScore === 'number' ? fScore : null),   // Français attendu par computeGroupStats()
                M:    (typeof mScore === 'number' ? mScore : null),   // Maths attendu par computeGroupStats()
                COM:  comVal,
                TRA:  traVal,
                PART: partVal,
                ABS:  absVal
              },

              // Duplication top-level pour l'UI comportement
              com:  comVal,
              tra:  traVal,
              part: partVal,
              abs:  absVal,

              // Duplication top-level pour debug ou affichage direct si besoin
              scoreF: fScore,
              scoreM: mScore
            };

            students.push(normalized);
          });
        });

        // CORRECTIF A : Appliquer normalizeScores sur chaque élève
        // pour garantir que scores.F et scores.M existent quelle que soit la source
        state.students = students.map(normalizeScores);
        state.studentsById = new Map(state.students.map(s => [s.id, s]));

        console.log(`[GroupsModule] 📊 Total d'élèves chargés: ${state.students.length}`);
        console.log('[GroupsModule] 🔍 DEBUG - Premier élève normalisé:', state.students[0]);
        console.log('[GroupsModule] ✅ Scores normalisés pour tous les élèves');

        resolve(students);
      } catch (error) {
        console.error('[GroupsModule] Erreur loadStudentsFromClasses:', error);
        showToast('❌ Erreur lors du chargement des élèves', 'error');
        reject(error);
      }
    });
  }

  // ═══════════════════════════════════════════════════════════════
  //  GÉNÉRATION DES GROUPES
  // ═══════════════════════════════════════════════════════════════

  // ═══════════════════════════════════════════════════════════════
  //  HELPERS POUR RÉPARTITION INTELLIGENTE
  // ═══════════════════════════════════════════════════════════════

  function getNeedScoreForStudent(stu) {
    // récupère F / M tels qu'on les a normalisés
    const f = (typeof stu.scores?.F === 'number') ? stu.scores.F : null;
    const m = (typeof stu.scores?.M === 'number') ? stu.scores.M : null;

    // selon le réglage de l'UI
    if (state.selectedSubject === 'maths') {
      return (m !== null ? m : 0);
    }
    if (state.selectedSubject === 'french') {
      return (f !== null ? f : 0);
    }

    // both -> on prend la moyenne dispo
    if (f !== null && m !== null) return (f + m) / 2;
    if (f !== null) return f;
    if (m !== null) return m;
    return 0;
  }

  // tri décroissant : meilleurs en premier
  function sortByNeedScoreDesc(students) {
    return [...students].sort((a, b) => {
      return getNeedScoreForStudent(b) - getNeedScoreForStudent(a);
    });
  }

  function generateGroupsLocally() {
    const num = state.numGroups || 3;
    if (!Array.isArray(state.students) || state.students.length === 0) {
      console.warn('[GroupsModule] Pas d\'élèves pour générer les groupes');
      state.generatedGroups = [];
      return;
    }

    // 1. On trie par niveau (note haute -> élève "fort")
    const sorted = sortByNeedScoreDesc(state.students);
    console.log('[GroupsModule] 📊 Distribution par mode:', state.distributionType);
    console.log('[GroupsModule] Top 3 élèves:', sorted.slice(0, 3).map(s => `${s.nom} (${getNeedScoreForStudent(s).toFixed(1)})`));

    // 🔴 FIX PARITÉ : Entrelacers filles et garçons pour équilibrer
    const girls = sorted.filter(s => (s.sexe || '').toUpperCase() === 'F');
    const boys = sorted.filter(s => (s.sexe || '').toUpperCase() === 'M');
    const other = sorted.filter(s => {
      const sx = (s.sexe || '').toUpperCase();
      return sx !== 'F' && sx !== 'M';
    });

    console.log('[GroupsModule] 👩 Filles: ' + girls.length + ' | 👨 Garçons: ' + boys.length + ' | ❓ Autres: ' + other.length);

    // Entrelacers F et M en gardant l'ordre de score
    const balanced = [];
    const maxLen = Math.max(girls.length, boys.length);
    for (let i = 0; i < maxLen; i++) {
      if (i < girls.length) balanced.push(girls[i]);
      if (i < boys.length) balanced.push(boys[i]);
    }
    // Ajouter les autres à la fin
    balanced.push(...other);

    console.log('[GroupsModule] ✅ Liste équilibrée (F/M entrelacées): ' + balanced.length + ' élèves');

    // 2. On prépare les groupes
    const groups = Array.from({ length: num }, (_, idx) => ({
      name: `Groupe ${idx + 1}`,
      students: []
    }));

    if (state.distributionType === 'homogeneous') {
      // homogène = on prend le tri équilibré et on découpe en blocs séquentiels
      const chunkSize = Math.ceil(balanced.length / num);
      for (let g = 0; g < num; g++) {
        const slice = balanced.slice(g * chunkSize, (g + 1) * chunkSize);
        groups[g].students.push(...slice);
      }
      console.log('[GroupsModule] ✅ Distribution homogène (groupes de niveau + équilibre F/M)');
    } else {
      // heterogeneous = on fait un snake draft sur la liste équilibrée :
      // 1er tour: G1,G2,G3
      // 2e tour: G3,G2,G1
      // 3e tour: G1,G2,G3...
      let forward = true;
      let index = 0;
      balanced.forEach(stu => {
        groups[index].students.push(stu);

        if (forward) {
          index++;
          if (index >= num) {
            index = num - 1;
            forward = false;
          }
        } else {
          index--;
          if (index < 0) {
            index = 0;
            forward = true;
          }
        }
      });
      console.log('[GroupsModule] ✅ Distribution hétérogène (équilibrée par niveau + F/M)');
    }

    state.generatedGroups = groups;
    state.lastGeneration = new Date();

    // Log de vérification
    groups.forEach((g, idx) => {
      const avgScore = g.students.length > 0
        ? (g.students.reduce((sum, s) => sum + getNeedScoreForStudent(s), 0) / g.students.length).toFixed(1)
        : 0;
      console.log(`[GroupsModule] Groupe ${idx + 1}: ${g.students.length} élèves, niveau moyen: ${avgScore}`);
    });
  }

  function generateGroups() {
    state.isLoading = true;
    state.loadError = null;
    updateUI();

    const ensureStudentsReady = state.students && state.students.length > 0
      ? Promise.resolve(state.students)
      : loadStudentsFromClasses();

    ensureStudentsReady
      .then(() => {
        generateGroupsLocally(); // crée state.generatedGroups
        state.isLoading = false;
        state.currentStep = 5;   // on passe à l'aperçu
        updateUI();
        showToast(`${state.generatedGroups.length} groupes générés`, 'success');
      })
      .catch(err => {
        state.isLoading = false;
        state.loadError = err?.message || String(err);
        updateUI();
        showToast('Impossible de générer les groupes', 'error');
      });
  }

  // ═══════════════════════════════════════════════════════════════
  //  DRAG & DROP avec SortableJS
  // ═══════════════════════════════════════════════════════════════

  function initializeDragAndDrop() {
    // Nettoyer les anciens sortables
    state.sortables.forEach(sortable => {
      try {
        sortable.destroy();
      } catch (e) {}
    });
    state.sortables = [];

    // Vérifier que Sortable est disponible
    if (typeof Sortable === 'undefined') {
      console.warn('⚠️ SortableJS non disponible, drag & drop désactivé');
      return;
    }

    // Créer un sortable pour chaque groupe
    qsa('[data-group-id]', state.modal).forEach(groupEl => {
      const groupId = parseInt(groupEl.dataset.groupId);

      const sortable = Sortable.create(groupEl, {
        group: 'groups',
        animation: 200,
        handle: '.student-card',
        ghostClass: 'sortable-ghost',
        chosenClass: 'sortable-chosen',
        dragClass: 'sortable-drag',

        onEnd: function(evt) {
          const fromGroupId = parseInt(evt.from.dataset.groupId);
          const toGroupId = parseInt(evt.to.dataset.groupId);
          const studentId = evt.item.dataset.studentId;

          if (fromGroupId !== toGroupId) {
            moveStudent(studentId, fromGroupId, toGroupId);
          }
        }
      });

      state.sortables.push(sortable);
    });
  }

  function moveStudent(studentId, fromGroupIndex, toGroupIndex) {
    // Trouver l'élève dans le groupe source
    const fromGroup = state.generatedGroups[fromGroupIndex];
    const studentIndex = fromGroup.students.findIndex(s => s.id === studentId);

    if (studentIndex === -1) return;

    const student = fromGroup.students[studentIndex];

    // Retirer du groupe source
    fromGroup.students.splice(studentIndex, 1);

    // Ajouter au groupe cible
    state.generatedGroups[toGroupIndex].students.push(student);

    // Mettre à jour l'affichage des stats
    updateGroupStats(fromGroupIndex);
    updateGroupStats(toGroupIndex);

    showToast(`${student.nom} déplacé vers ${state.generatedGroups[toGroupIndex].name}`, 'info', 2000);
  }

  function updateGroupStats(groupIndex) {
    const groupCard = qs(`[data-group-index="${groupIndex}"]`, state.modal);
    if (!groupCard) return;

    const group = state.generatedGroups[groupIndex];
    const stats = calculateGroupStats(group);

    // Update count
    const countEl = qs('.group-count', groupCard);
    if (countEl) countEl.textContent = `${group.students.length} élèves`;

    // Update stats
    const statsContainer = qs('.group-stats', groupCard);
    if (statsContainer) {
      statsContainer.innerHTML = `
        <div class="stat-item">
          <i class="fas fa-venus-mars text-pink-600"></i>
          <span>${stats.girls}F / ${stats.boys}M</span>
        </div>
        ${state.groupType === 'needs' ? `
          <div class="stat-item">
            <i class="fas fa-chart-line text-blue-600"></i>
            <span>Moy: ${stats.avgScore}</span>
          </div>
        ` : ''}
        ${state.groupType === 'language' ? `
          <div class="stat-item">
            <i class="fas fa-comments text-purple-600"></i>
            <span>PART: ${stats.avgPart}</span>
          </div>
        ` : ''}
      `;
    }
  }

  // ═══════════════════════════════════════════════════════════════
  //  SAUVEGARDE & EXPORT
  // ═══════════════════════════════════════════════════════════════

  function saveTempGroupsUI() {
    if (!google?.script?.run) {
      showToast('Google Apps Script non disponible', 'error');
      return;
    }

    if (!state.generatedGroups || state.generatedGroups.length === 0) {
      showToast('Aucun groupe à sauvegarder', 'warning');
      return;
    }

    // D'abord vérifier s'il y a des TEMP existants pour ce type
    showToast('Vérification des groupes existants...', 'info');

    google.script.run
      .withSuccessHandler((listResult) => {
        // Si des TEMP existent, vérifier le mode utilisateur
        if (listResult.success && listResult.count > 0) {
          const existingInfo = `Groupes TEMP existants trouvés: ${listResult.minNumber} à ${listResult.maxNumber} (${listResult.count} groupes)`;
          console.log(existingInfo);

          // Si mode='replace', demander confirmation
          if (state.saveMode === 'replace') {
            const confirmReplace = confirm(
              `⚠️ Mode REMPLACER activé!\n\n${existingInfo}\n\n` +
              `Si vous continuez, vous PERDREZ ces ${listResult.count} groupes temporaires!\n\n` +
              `Vos groupes seront renumérotés de 1 à ${state.generatedGroups.length}.\n\n` +
              `Souhaitez-vous continuer?`
            );
            if (!confirmReplace) {
              showToast('Sauvegarde annulée', 'warning');
              return;
            }
          } else {
            // Mode='append': informer l'utilisateur que ça va s'ajouter
            showToast(
              `Mode AJOUTER: vos groupes seront numérotés de ${listResult.maxNumber + 1} à ${listResult.maxNumber + state.generatedGroups.length}`,
              'info'
            );
          }
        } else {
          // Aucun TEMP existant
          console.log('Aucun groupe TEMP existant pour ce type');
        }

        // Procéder à la sauvegarde
        proceedWithSave();
      })
      .withFailureHandler(error => {
        console.error('Erreur listTempGroups:', error);
        // En cas d'erreur, continuer quand même
        showToast('Impossible de vérifier les groupes existants, sauvegarde directe...', 'warning');
        proceedWithSave();
      })
      .listTempGroups(state.groupType);

    function proceedWithSave() {
      const payload = {
        type: state.groupType,
        saveMode: state.saveMode,  // 'replace' | 'append'
        config: {
          selectedClasses: state.selectedClasses,
          numGroups: state.numGroups,
          ...(state.groupType === 'needs' && {
            subject: state.selectedSubject,
            distributionType: state.distributionType
          }),
          ...(state.groupType === 'language' && {
            language: state.selectedLanguage
          })
        },
        groups: state.generatedGroups,
        timestamp: new Date().toISOString()
      };

      showToast('💾 Sauvegarde temporaire en cours...', 'info');

      google.script.run
        .withSuccessHandler((result) => {
          if (result.success) {
            const modeLabel = result.saveMode === 'append' ? 'ajoutés' : 'enregistrés';
            showToast(
              `✅ Groupes ${modeLabel} de ${result.startNum} à ${result.endNum} ` +
              `(${result.totalGroups} groupes, ${result.totalEleves} élèves)`,
              'success'
            );
            console.log('[GroupsModule] Sauvegarde temp réussie:', result);
          } else {
            showToast(`Erreur: ${result.error}`, 'error');
          }
        })
        .withFailureHandler(error => {
          showToast(`Erreur de sauvegarde : ${error?.message || error}`, 'error');
        })
        .saveTempGroups(payload);
    }
  }

  function finalizeTempGroupsUI() {
    if (!google?.script?.run) {
      showToast('Google Apps Script non disponible', 'error');
      return;
    }

    const typeMap = {
      'needs': 'Groupes de Besoin',
      'language': 'Groupes de Langue',
      'options': 'Groupes d\'Options'
    };

    const typeName = typeMap[state.groupType] || state.groupType;

    // Déterminer le finalizeMode basé sur saveMode
    // Si saveMode='replace' → finalize='replace' (comportement actuel)
    // Si saveMode='append' → finalize='merge' (cumule avec existants)
    const finalizeMode = state.saveMode === 'append' ? 'merge' : 'replace';

    const modeLabel = finalizeMode === 'merge' ? 'en fusionnant' : 'en remplaçant les anciens';
    showToast(`🎯 Finalisation de ${typeName} ${modeLabel}...`, 'info');

    google.script.run
      .withSuccessHandler((result) => {
        if (result.success) {
          showToast(`✅ ${typeName} finalisés ! (${result.prefix}1, ${result.prefix}2, ...)`, 'success');
          console.log('[GroupsModule] Finalisation réussie:', result);
        } else {
          showToast(`Erreur: ${result.error}`, 'error');
        }
      })
      .withFailureHandler(error => {
        showToast(`Erreur de finalisation : ${error?.message || error}`, 'error');
      })
      .finalizeTempGroups(state.groupType, finalizeMode);
  }

  function loadTempGroupsUI() {
    if (!google?.script?.run) {
      showToast('Google Apps Script non disponible', 'error');
      return;
    }

    // D'abord, vérifier quels TEMP existent
    showToast('Vérification des groupes temporaires...', 'info');

    google.script.run
      .withSuccessHandler((listResult) => {
        if (listResult.success && listResult.count > 0) {
          var tempInfo = 'Groupes TEMP existants: ' +
            listResult.minNumber + ' à ' + listResult.maxNumber +
            ' (' + listResult.count + ' groupes, ' + listResult.totalStudents + ' élèves)';
          console.log(tempInfo);

          // Maintenant charger les groupes
          showToast('📥 Chargement des groupes temporaires...', 'info');

          google.script.run
            .withSuccessHandler((result) => {
              if (result.success && result.groups && result.groups.length > 0) {
                state.generatedGroups = result.groups;
                state.currentStep = 5;
                updateUI();
                var totalStudents = result.groups.reduce((sum, g) => sum + (g.students ? g.students.length : 0), 0);
                showToast('✅ ' + result.totalGroups + ' groupes chargés (' + totalStudents + ' élèves)', 'success');
                console.log('[GroupsModule] Groupes chargés:', state.generatedGroups);
              } else {
                showToast('Impossible de charger les groupes temporaires', 'warning');
              }
            })
            .withFailureHandler(error => {
              showToast('Erreur de chargement : ' + (error?.message || error), 'error');
            })
            .loadTempGroups(state.groupType);
        } else {
          showToast('Aucun groupe temporaire trouvé pour le type: ' + state.groupType, 'warning');
        }
      })
      .withFailureHandler(error => {
        console.error('Erreur listTempGroups:', error);
        showToast('Impossible de lister les groupes: ' + (error?.message || error), 'error');
      })
      .listTempGroups(state.groupType);
  }

  // Alias pour compatibilité avec anciens appels
  function saveGroups() {
    saveTempGroupsUI();
  }

  function exportToPDF() {
    showToast('Export PDF en développement', 'info');
    // TODO: Implémenter export PDF
  }

  function exportToCSV() {
    if (!state.generatedGroups || state.generatedGroups.length === 0) {
      showToast('Aucun groupe à exporter', 'warning');
      return;
    }

    // Créer le CSV
    let csv = 'Groupe,Nom,Prénom,Sexe,Classe,LV2\n';

    state.generatedGroups.forEach(group => {
      group.students.forEach(student => {
        csv += `"${group.name}","${student.nom}","${student.prenom}","${student.sexe || ''}","${student.classe || ''}","${student.lv2 || ''}"\n`;
      });
    });

    // Télécharger
    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const link = documentRef.createElement('a');
    link.href = url;
    link.download = `groupes_${new Date().toISOString().split('T')[0]}.csv`;
    documentRef.body.appendChild(link);
    link.click();
    documentRef.body.removeChild(link);
    URL.revokeObjectURL(url);

    showToast('Export CSV téléchargé', 'success');
  }

  // ═══════════════════════════════════════════════════════════════
  //  STYLES CSS
  // ═══════════════════════════════════════════════════════════════

  function injectStyles() {
    if (documentRef.getElementById('groups-module-complete-styles')) return;

    const style = documentRef.createElement('style');
    style.id = 'groups-module-complete-styles';
    style.textContent = `
      @keyframes fade-in {
        from { opacity: 0; }
        to { opacity: 1; }
      }

      @keyframes slide-in {
        from { transform: translateX(30px); opacity: 0; }
        to { transform: translateX(0); opacity: 1; }
      }

      .animate-fade-in { animation: fade-in 0.2s ease; }
      .animate-slide-in { animation: slide-in 0.3s ease; }

      /* STEPPER */
      .stepper-step {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        transition: all 0.3s ease;
      }

      .step-number {
        width: 2rem;
        height: 2rem;
        border-radius: 50%;
        background: #e2e8f0;
        color: #64748b;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: 600;
        font-size: 0.875rem;
        transition: all 0.3s ease;
      }

      .step-label {
        font-size: 0.75rem;
        font-weight: 600;
        color: #64748b;
        transition: all 0.3s ease;
      }

      .stepper-step.active .step-number {
        background: linear-gradient(135deg, #6366f1, #7c3aed);
        color: white;
        box-shadow: 0 4px 12px rgba(99, 102, 241, 0.4);
      }

      .stepper-step.active .step-label {
        color: #4f46e5;
      }

      .stepper-step.current .step-number {
        transform: scale(1.1);
      }

      .step-connector {
        flex: 1;
        height: 2px;
        background: #e2e8f0;
        transition: all 0.3s ease;
      }

      /* GROUP TYPE CARDS */
      .group-type-card {
        position: relative;
        border: 3px solid #e2e8f0;
        border-radius: 1.5rem;
        padding: 2rem;
        text-align: center;
        cursor: pointer;
        transition: all 0.3s ease;
        background: white;
      }

      .group-type-card:hover:not(.disabled) {
        transform: translateY(-4px);
        box-shadow: 0 20px 40px -20px rgba(99, 102, 241, 0.3);
        border-color: #c7d2fe;
      }

      .group-type-card.selected {
        border-color: #6366f1;
        background: linear-gradient(135deg, #eff6ff, #faf5ff);
      }

      .group-type-card.disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      .group-type-card .icon-wrapper {
        margin-bottom: 1rem;
      }

      .group-type-card .icon {
        font-size: 3rem;
      }

      .group-type-card .title {
        font-size: 1.25rem;
        font-weight: 700;
        color: #1e293b;
        margin-bottom: 0.5rem;
      }

      .group-type-card .description {
        font-size: 0.875rem;
        color: #64748b;
        line-height: 1.5;
      }

      .group-type-card .check-icon {
        position: absolute;
        top: 1rem;
        right: 1rem;
        font-size: 1.5rem;
        color: #6366f1;
      }

      .badge-disabled {
        display: inline-block;
        margin-top: 0.5rem;
        padding: 0.25rem 0.75rem;
        background: #fbbf24;
        color: white;
        border-radius: 999px;
        font-size: 0.75rem;
        font-weight: 600;
      }

      .badge-recommended {
        display: inline-block;
        padding: 0.25rem 0.75rem;
        background: #10b981;
        color: white;
        border-radius: 999px;
        font-size: 0.75rem;
        font-weight: 600;
      }

      /* INFO CARDS */
      .info-card {
        border: 2px solid;
        border-radius: 1.25rem;
        padding: 1.5rem;
      }

      /* CLASS SELECTION */
      .class-checkbox-card {
        position: relative;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 0.75rem;
        border: 2px solid #e2e8f0;
        border-radius: 0.75rem;
        cursor: pointer;
        transition: all 0.2s ease;
        background: white;
      }

      .class-checkbox-card:hover {
        border-color: #c7d2fe;
        background: #f8fafc;
      }

      .class-checkbox-card.selected {
        border-color: #6366f1;
        background: linear-gradient(135deg, #eff6ff, #faf5ff);
      }

      .class-checkbox {
        position: absolute;
        opacity: 0;
        pointer-events: none;
      }

      .class-name {
        font-weight: 600;
        color: #1e293b;
      }

      .class-checkbox-card .check-icon {
        position: absolute;
        top: 0.25rem;
        right: 0.25rem;
        font-size: 1rem;
        color: #6366f1;
        opacity: 0;
        transition: opacity 0.2s ease;
      }

      .class-checkbox-card.selected .check-icon {
        opacity: 1;
      }

      /* CONFIG CARDS */
      .config-card {
        border: 2px solid #e2e8f0;
        border-radius: 1.25rem;
        background: white;
        overflow: hidden;
      }

      .config-header {
        display: flex;
        align-items: center;
        gap: 1rem;
        padding: 1.5rem;
        background: linear-gradient(135deg, #f8fafc, #f1f5f9);
        border-bottom: 1px solid #e2e8f0;
      }

      .config-body {
        padding: 1.5rem;
      }

      .radio-card {
        position: relative;
        display: flex;
        align-items: center;
        gap: 1rem;
        padding: 1rem;
        border: 2px solid #e2e8f0;
        border-radius: 0.75rem;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .radio-card:hover {
        border-color: #c7d2fe;
        background: #f8fafc;
      }

      .radio-card.selected {
        border-color: #6366f1;
        background: linear-gradient(135deg, #eff6ff, #faf5ff);
      }

      .radio-card input[type="radio"] {
        position: absolute;
        opacity: 0;
        pointer-events: none;
      }

      .radio-card .check-icon {
        margin-left: auto;
        color: #6366f1;
        opacity: 0;
        transition: opacity 0.2s ease;
      }

      .radio-card.selected .check-icon {
        opacity: 1;
      }

      .number-btn {
        width: 2.5rem;
        height: 2.5rem;
        border-radius: 0.5rem;
        border: 2px solid #e2e8f0;
        background: white;
        color: #64748b;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .number-btn:hover {
        border-color: #6366f1;
        color: #6366f1;
        background: #eff6ff;
      }

      .number-display {
        font-size: 2rem;
        font-weight: 700;
        color: #6366f1;
        min-width: 3rem;
        text-align: center;
      }

      /* SUMMARY CARDS */
      .summary-card {
        display: flex;
        align-items: center;
        gap: 1rem;
        padding: 1.5rem;
        border: 2px solid #e2e8f0;
        border-radius: 1.25rem;
        background: white;
      }

      .summary-icon {
        width: 3.5rem;
        height: 3.5rem;
        border-radius: 1rem;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1.5rem;
        color: white;
      }

      .summary-label {
        font-size: 0.75rem;
        font-weight: 600;
        color: #64748b;
        text-transform: uppercase;
        letter-spacing: 0.05em;
      }

      .summary-value {
        font-size: 1.125rem;
        font-weight: 700;
        color: #1e293b;
        margin-top: 0.25rem;
      }

      /* GROUP CARDS */
      .group-card {
        border: 2px solid #e2e8f0;
        border-radius: 1.25rem;
        background: white;
        overflow: hidden;
        transition: all 0.2s ease;
        display: flex;
        flex-direction: column;
        height: 100%;
        min-height: 150px; /* hauteur min réduite pour maximiser l'espace de liste */
      }

      .group-card:hover {
        box-shadow: 0 8px 24px -12px rgba(0, 0, 0, 0.15);
      }

      .group-header {
        padding: 1rem 1.25rem;
        background: linear-gradient(135deg, #6366f1, #7c3aed);
        color: white;
        display: flex;
        align-items: center;
        justify-content: space-between;
        flex-shrink: 0;
      }

      .group-title {
        font-weight: 700;
        font-size: 1rem;
      }

      .group-count {
        font-size: 0.875rem;
        opacity: 0.9;
      }

      .group-stats {
        padding: 0.75rem 1.25rem;
        background: #f8fafc;
        border-bottom: 1px solid #e2e8f0;
        display: flex;
        gap: 1rem;
        flex-wrap: wrap;
        flex-shrink: 0;
      }

      .stat-item {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        font-size: 0.875rem;
        font-weight: 600;
        color: #475569;
      }

      .group-students {
        padding: 1rem;
        overflow-y: auto;
        flex: 1; /* Prend tout l'espace disponible */
        min-height: 0; /* Important pour flexbox : permet au scroll de marcher */
        scrollbar-width: thin;
        scrollbar-color: #cbd5e1 #f1f5f9;
      }

      /* Scrollbar personnalisée (Webkit) */
      .group-students::-webkit-scrollbar {
        width: 6px;
      }

      .group-students::-webkit-scrollbar-track {
        background: #f1f5f9;
        border-radius: 3px;
      }

      .group-students::-webkit-scrollbar-thumb {
        background: #cbd5e1;
        border-radius: 3px;
      }

      .group-students::-webkit-scrollbar-thumb:hover {
        background: #94a3b8;
      }

      /* STUDENT CARDS */
      .student-card {
        display: flex;
        align-items: center;
        gap: 0.375rem;
        padding: 0.375rem;
        margin-bottom: 0.25rem;
        border: 1px solid #e2e8f0;
        border-radius: 0.5rem;
        background: white;
        cursor: move;
        transition: all 0.2s ease;
        font-size: 0.8rem;
      }

      .student-card:hover {
        border-color: #c7d2fe;
        background: #f8fafc;
        box-shadow: 0 2px 8px -4px rgba(99, 102, 241, 0.2);
      }

      .student-sexe {
        width: 1.5rem;
        height: 1.5rem;
        border-radius: 0.375rem;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: 700;
        font-size: 0.75rem;
      }

      .student-sexe.sexe-f {
        background: #fce7f3;
        color: #ec4899;
      }

      .student-sexe.sexe-m {
        background: #dbeafe;
        color: #3b82f6;
      }

      .student-name {
        font-weight: 600;
        font-size: 0.8rem;
        color: #1e293b;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        flex-shrink: 1;
        min-width: 0;
      }

      .student-meta {
        font-size: 0.7rem;
        color: #64748b;
        white-space: nowrap;
      }

      .student-source {
        font-size: 0.7rem;
        color: #94a3b8;
        white-space: nowrap;
      }

      .student-scores {
        display: flex;
        gap: 0.5rem;
        margin-left: auto;
      }

      .score-badge {
        padding: 0.2rem 0.4rem;
        background: #f1f5f9;
        border-radius: 0.375rem;
        font-size: 0.7rem;
        font-weight: 600;
        color: #475569;
        white-space: nowrap;
      }

      .score-badge.avg {
        background: linear-gradient(135deg, #6366f1, #7c3aed);
        color: white;
      }

      .drag-handle {
        cursor: grab;
      }

      .drag-handle:active {
        cursor: grabbing;
      }

      /* SORTABLE STATES */
      .sortable-ghost {
        opacity: 0.4;
        background: #eff6ff;
      }

      .sortable-chosen {
        border-color: #6366f1;
        box-shadow: 0 8px 24px -12px rgba(99, 102, 241, 0.4);
      }

      .sortable-drag {
        transform: rotate(3deg);
      }

      /* ACTION BUTTONS */
      .action-btn {
        display: inline-flex;
        align-items: center;
        gap: 0.5rem;
        padding: 0.5rem 1rem;
        border-radius: 0.75rem;
        font-weight: 600;
        font-size: 0.875rem;
        cursor: pointer;
        transition: all 0.2s ease;
        border: none;
      }

      .action-btn:hover {
        transform: translateY(-1px);
        box-shadow: 0 4px 12px -6px rgba(0, 0, 0, 0.2);
      }

      /* SPINNERS */
      .spinner-large {
        width: 4rem;
        height: 4rem;
        border: 4px solid #e2e8f0;
        border-top-color: #6366f1;
        border-radius: 50%;
        animation: spin 1s linear infinite;
      }

      @keyframes spin {
        to { transform: rotate(360deg); }
      }

      .delay-100 { animation-delay: 0.1s; }
      .delay-200 { animation-delay: 0.2s; }
    `;

    documentRef.head.appendChild(style);
  }

  // ═══════════════════════════════════════════════════════════════
  //  MODULE PUBLIC API
  // ═══════════════════════════════════════════════════════════════

  const GroupsModuleComplete = {
    version: '1.0.0',

    init() {
      console.log('✅ GroupsModuleComplete initialisé');
    },

    open() {
      console.log('🚀 Ouverture du module complet de groupes');
      createModal();
    },

    close: closeModal,

    getState() {
      return { ...state };
    },

    // Fonctions publiques pour la gestion des groupes temporaires
    saveTempGroupsUI,
    loadTempGroupsUI,
    finalizeTempGroupsUI
  };

  // Injecter les styles
  injectStyles();

  // Exposer le module
  windowRef.GroupsModuleComplete = GroupsModuleComplete;

  // Initialisation automatique
  if (documentRef.readyState === 'loading') {
    documentRef.addEventListener('DOMContentLoaded', () => {
      GroupsModuleComplete.init();
    });
  } else {
    GroupsModuleComplete.init();
  }

  console.log('✅ Module Complet de Gestion des Groupes chargé avec succès');

})(typeof window !== 'undefined' ? window : this);
</script>
